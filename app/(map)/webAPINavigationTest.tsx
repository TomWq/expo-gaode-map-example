
import { RouteCard } from '@/components/RouteCard';
import { RouteInfoCard } from '@/components/RouteInfoCard';
import { useAddressSearch } from '@/hooks/useAddressSearch';
import { RouteData, useRoutePlanning } from '@/hooks/useRoutePlanning';
import { getRouteBounds, simplifyPath } from '@/utils/routeUtils';
import { useHeaderHeight } from '@react-navigation/elements';
import { BlurView } from 'expo-blur';
import { ExpoGaodeMapModule, MapView, MapViewRef, Marker, Polyline } from 'expo-gaode-map';
import { GaodeWebAPI } from 'expo-gaode-map-web-api';
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { ActivityIndicator, FlatList, Keyboard, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import Animated, {
  Easing,
  runOnJS,
  useAnimatedProps,
  useSharedValue,
  withTiming
} from 'react-native-reanimated';
import { toast } from 'sonner-native';

// åˆ›å»ºåŠ¨ç”»ç»„ä»¶
const AnimatedPolyline = Animated.createAnimatedComponent(Polyline);
const AnimatedMarker = Animated.createAnimatedComponent(Marker);

export default function WebAPINavigationTest() {

   const api = useMemo(() => new GaodeWebAPI({ key: '' }), []);
  const headerHeight = useHeaderHeight();
  
  // ä½¿ç”¨è‡ªå®šä¹‰ Hooks
  const routePlanning = useRoutePlanning(api);
  const addressSearch = useAddressSearch();
  
  const [originText, setOriginText] = useState('å½“å‰ä½ç½®');
  const [destinationText, setDestinationText] = useState('åŒ—äº¬å—ç«™');
  
  const [selectedOrigin, setSelectedOrigin] = useState<{
    latitude: number;
    longitude: number;
    name: string;
    address: string;
  } | null>(null);
  
  const [selectedDestination, setSelectedDestination] = useState<{
    latitude: number;
    longitude: number;
    name: string;
    address: string;
  } | null>(null);
  
  const [currentLocation, setCurrentLocation] = useState<{
    latitude: number;
    longitude: number;
  } | null>(null);
  
  const [isAnimating, setIsAnimating] = useState(false);
  const [fullPathData, setFullPathData] = useState<Array<{ latitude: number; longitude: number }>>([]);
  const [selectedRouteIndex, setSelectedRouteIndex] = useState<number>(-1);
  const [routeResult, setRouteResult] = useState<RouteData | null>(null);
  
  // Reanimated shared values
  const animationProgress = useSharedValue(0);
  const totalPointsShared = useSharedValue(0);
  
  const mapRef = useRef<MapViewRef>(null);

  // åˆå§‹åŒ– API
  useEffect(() => {

    // è®¾ç½®é»˜è®¤ç»ˆç‚¹
    setSelectedDestination({
      latitude: 39.865195,
      longitude: 116.378865,
      name: 'åŒ—äº¬å—ç«™',
      address: 'åŒ—äº¬å¸‚ä¸°å°åŒºæ°¸å¤–å¤§è¡—è½¦ç«™è·¯12å·',
    });
  }, []);

  // è·å–å½“å‰ä½ç½®
  const getCurrentLocation = async () => {
    try {
      const location = await ExpoGaodeMapModule.getCurrentLocation();
      
      if (location) {
        setCurrentLocation({
          latitude: location.latitude,
          longitude: location.longitude,
        });
        
        setOriginText('å½“å‰ä½ç½®');
        setSelectedOrigin({
          latitude: location.latitude,
          longitude: location.longitude,
          name: 'å½“å‰ä½ç½®',
          address: 'å½“å‰ä½ç½®',
        });
        
        mapRef.current?.moveCamera({
          target: {
            latitude: location.latitude,
            longitude: location.longitude,
          },
          zoom: 14,
        }, 1000);
        
        toast.success('ä½ç½®è·å–æˆåŠŸ');
      }
    } catch (error) {
      console.error('[WebAPI] è·å–ä½ç½®å¤±è´¥:', error);
      toast.error('è·å–ä½ç½®å¤±è´¥ï¼Œè¯·æ£€æŸ¥å®šä½æƒé™');
    }
  };

  // å¤„ç†æœç´¢è¾“å…¥
  const handleSearchInput = (text: string, inputType: 'origin' | 'destination') => {
    if (inputType === 'origin') {
      setOriginText(text);
    } else {
      setDestinationText(text);
    }
    addressSearch.handleSearchChange(text, inputType);
  };

  // é€‰æ‹©åœ°å€
  const handleSelectAddress = async (suggestion: any) => {
    const location = await addressSearch.selectSuggestion(suggestion);
    if (!location) return;

    if (addressSearch.activeInput === 'origin') {
      setOriginText(suggestion.name);
      setSelectedOrigin(location);
    } else {
      setDestinationText(suggestion.name);
      setSelectedDestination(location);
    }

    try {
      Keyboard.dismiss();
    } catch (e) {
      // ignore
    }

    // ç§»åŠ¨åœ°å›¾
    mapRef.current?.moveCamera({ target: location, zoom: 14 }, 500);
  };

  // æ¸…ç©ºæœç´¢
  const handleClearSearch = (inputType: 'origin' | 'destination') => {
    if (inputType === 'origin') {
      setOriginText('å½“å‰ä½ç½®');
      setSelectedOrigin(null);
    } else {
      setDestinationText('åŒ—äº¬å—ç«™');
      setSelectedDestination(null);
    }
    addressSearch.clearSearch();
  };

  // è§„åˆ’è·¯å¾„
  const calculateRoute = async () => {
    const originLocation = selectedOrigin || currentLocation;
    const destinationLocation = selectedDestination;

    if (!originLocation) {
      toast.info('è¯·å…ˆè·å–å½“å‰ä½ç½®æˆ–é€‰æ‹©å‡ºå‘ç‚¹');
      return;
    }

    if (!destinationLocation) {
      toast.info('è¯·é€‰æ‹©ç›®çš„åœ°');
      return;
    }

    const routes = await routePlanning.calculateRoute(originLocation, destinationLocation);
    if (routes) {
      setSelectedRouteIndex(-1);
      setRouteResult(null);
      setFullPathData([]);
    }
  };

  // ç›´æ¥æ˜¾ç¤ºå®Œæ•´è·¯çº¿ï¼ˆä¸æ’­æ”¾åŠ¨ç”»ï¼‰
  const showFullRoute = (fullPath: Array<{ latitude: number; longitude: number }>) => {
    const simplifiedPath = simplifyPath(fullPath, 150);
    console.log(`[WebAPI] æ˜¾ç¤ºå®Œæ•´è·¯çº¿ï¼Œç‚¹æ•°: ${fullPath.length}, ç®€åŒ–å: ${simplifiedPath.length}`);
    
    setFullPathData(simplifiedPath);
    setIsAnimating(false);
    
    const totalPoints = simplifiedPath.length;
    totalPointsShared.value = totalPoints;
    animationProgress.value = 1;
    
    // è°ƒæ•´è§†è§’
    const bounds = getRouteBounds(fullPath);
    if (bounds && mapRef.current) {
      setTimeout(() => {
        mapRef.current?.moveCamera({
          target: bounds.center,
          zoom: 13,
        }, 1000);
      }, 100);
    }
  };

  // åŠ¨ç”»æ˜¾ç¤ºè·¯å¾„ï¼ˆæ¨¡æ‹Ÿå¯¼èˆªï¼‰
  const animatePolyline = (fullPath: Array<{ latitude: number; longitude: number }>) => {
    setIsAnimating(true);
    
    const simplifiedPath = simplifyPath(fullPath, 150);
    console.log(`[WebAPIåŠ¨ç”»] åŸå§‹ç‚¹æ•°: ${fullPath.length}, ç®€åŒ–å: ${simplifiedPath.length}`);
    
    setFullPathData(simplifiedPath);
    
    const totalPoints = simplifiedPath.length;
    totalPointsShared.value = totalPoints;
    
    const duration = Math.max(4000, totalPoints * 20);
    
    const handleAnimationComplete = () => {
      setIsAnimating(false);
      
      const bounds = getRouteBounds(fullPath);
      if (bounds && mapRef.current) {
        setTimeout(() => {
          mapRef.current?.moveCamera({
            target: bounds.center,
            zoom: 13,
          }, 1000);
        }, 100);
      }
    };
    
    animationProgress.value = 0;
    animationProgress.value = withTiming(1, {
      duration,
      easing: Easing.linear,
    }, (finished) => {
      if (finished) {
        runOnJS(handleAnimationComplete)();
      }
    });
  };

  // åŠ¨ç”»è·¯å¾„æ˜¾ç¤º
  const animatedPolylineProps = useAnimatedProps(() => {
    'worklet';
    const totalPoints = totalPointsShared.value;
    if (totalPoints === 0 || fullPathData.length === 0) {
      return { points: [] };
    }
    
    const currentPointCount = Math.ceil(animationProgress.value * totalPoints);
    const visiblePoints = fullPathData.slice(0, Math.max(2, currentPointCount));
    
    return {
      points: visiblePoints,
    };
  }, [fullPathData]);

  // åŠ¨ç”» Marker ä½ç½®
  const animatedMarkerPosition = useAnimatedProps(() => {
    'worklet';
    const totalPoints = totalPointsShared.value;
    if (totalPoints === 0 || fullPathData.length === 0) {
      return { position: { latitude: 0, longitude: 0 } };
    }
    
    const currentIndex = Math.floor(animationProgress.value * (totalPoints - 1));
    const safeIndex = Math.min(Math.max(0, currentIndex), totalPoints - 1);
    
    return {
      position: fullPathData[safeIndex],
    };
  }, [fullPathData]);

  // å®šæœŸç§»åŠ¨ç›¸æœºè·ŸéšåŠ¨ç”»
  useEffect(() => {
    if (!isAnimating || fullPathData.length === 0) return;
    
    const interval = setInterval(() => {
      const progress = animationProgress.value;
      const currentIndex = Math.floor(progress * fullPathData.length);
      
      if (currentIndex > 0 && currentIndex < fullPathData.length) {
        const currentPos = fullPathData[currentIndex];
        mapRef.current?.moveCamera({
          target: currentPos,
          zoom: 15,
        }, 300);
      }
    }, 500);
    
    return () => clearInterval(interval);
  }, [isAnimating, fullPathData]);

  // é€‰æ‹©è·¯çº¿
  const handleSelectRoute = (route: RouteData, index: number) => {
    setSelectedRouteIndex(index);
    setRouteResult(route);
    if (route.polyline && route.polyline.length > 0) {
      showFullRoute(route.polyline);
    }
  };

  // åˆ‡æ¢å‡ºè¡Œæ–¹å¼
  const handleChangeRouteType = (type: typeof routePlanning.routeType) => {
    routePlanning.setRouteType(type);
    routePlanning.clearRoutes();
    setRouteResult(null);
    setFullPathData([]);
    setSelectedRouteIndex(-1);
  };

  return (
    <View style={styles.container}>
      <MapView
        ref={mapRef}
        style={styles.map}
        initialCameraPosition={{
          target: {
            latitude: 39.9042,
            longitude: 116.4074,
          },
          zoom: 12,
        }}
        myLocationEnabled={true}
        compassEnabled={true}
      >
        {/* å½“å‰ä½ç½® */}
        {currentLocation && (
          <Marker
            position={currentLocation}
            title="å½“å‰ä½ç½®"
            pinColor="green"
          />
        )}

        {/* è·¯å¾„çº¿ */}
        {fullPathData.length > 1 && routeResult && (
          <AnimatedPolyline
            points={fullPathData}
            animatedProps={animatedPolylineProps}
            strokeWidth={5}
            strokeColor={routeResult.color || "#2196F3"}
          />
        )}
        
        {/* åŠ¨ç”»æ ‡è®° */}
        {isAnimating && fullPathData.length > 0 && (
          <AnimatedMarker
            position={fullPathData[0]}
            animatedProps={animatedMarkerPosition}
            anchor={{ x: 0.5, y: 0.5 }}
            zIndex={99}
          >
            <Animated.View style={{
              width: 40,
              height: 40,
              alignItems: 'center',
              justifyContent: 'center'
            }}>
              <Text style={{ fontSize: 32 }}>
                {routePlanning.routeType === 'driving' ? 'ğŸš—' :
                 routePlanning.routeType === 'walking' ? 'ğŸš¶' :
                 routePlanning.routeType === 'bicycling' ? 'ğŸš´' : 'ğŸšŒ'}
              </Text>
            </Animated.View>
          </AnimatedMarker>
        )}
      </MapView>

      {/* é¡¶éƒ¨è¾“å…¥æ¡† */}
      <View style={[styles.topInputCard, {top: headerHeight}]}>
        <View style={styles.inputRow}>
          <Text style={styles.inputIcon}>ğŸ“</Text>
          <TextInput
            style={styles.input}
            value={originText}
            onChangeText={(text) => handleSearchInput(text, 'origin')}
            placeholder="è¯·è¾“å…¥å‡ºå‘ç‚¹"
            placeholderTextColor="#999"
            onFocus={() => addressSearch.setActiveInput('origin')}
          />
          {originText && originText !== 'å½“å‰ä½ç½®' && (
            <TouchableOpacity
              onPress={() => handleClearSearch('origin')}
              style={styles.clearButton}
            >
              <Text style={styles.clearIcon}>âœ•</Text>
            </TouchableOpacity>
          )}
          {addressSearch.loading && addressSearch.activeInput === 'origin' && (
            <ActivityIndicator size="small" color="#2196F3" />
          )}
        </View>
        
        <View style={styles.inputDivider} />
        
        <View style={styles.inputRow}>
          <Text style={styles.inputIcon}>ğŸ¯</Text>
          <TextInput
            style={styles.input}
            value={destinationText}
            onChangeText={(text) => handleSearchInput(text, 'destination')}
            placeholder="è¯·è¾“å…¥ç›®çš„åœ°"
            placeholderTextColor="#999"
            onFocus={() => addressSearch.setActiveInput('destination')}
          />
          {destinationText && destinationText !== 'åŒ—äº¬å—ç«™' && (
            <TouchableOpacity
              onPress={() => handleClearSearch('destination')}
              style={styles.clearButton}
            >
              <Text style={styles.clearIcon}>âœ•</Text>
            </TouchableOpacity>
          )}
          {addressSearch.loading && addressSearch.activeInput === 'destination' && (
            <ActivityIndicator size="small" color="#2196F3" />
          )}
        </View>
      </View>

      {/* æœç´¢å»ºè®®åˆ—è¡¨ */}
      {addressSearch.showSuggestions && addressSearch.searchSuggestions.length > 0 && (
        <View style={styles.suggestionsContainer}>
          <FlatList
            data={addressSearch.searchSuggestions}
            keyExtractor={(item) => item.id}
            renderItem={({ item }) => (
              <TouchableOpacity
                style={styles.suggestionItem}
                onPress={() => handleSelectAddress(item)}
                disabled={addressSearch.loading}
              >
                <View style={styles.suggestionIcon}>
                  <Text>ğŸ“</Text>
                </View>
                <View style={styles.suggestionContent}>
                  <Text style={styles.suggestionName} numberOfLines={1}>
                    {item.name}
                  </Text>
                  <Text style={styles.suggestionAddress} numberOfLines={1}>
                    {item.address}
                  </Text>
                </View>
              </TouchableOpacity>
            )}
            keyboardShouldPersistTaps="handled"
          />
        </View>
      )}

      {/* åº•éƒ¨æ“ä½œå¡ç‰‡ */}
      <View style={styles.bottomCard}>
        <ScrollView
          showsVerticalScrollIndicator={false}
          contentContainerStyle={styles.bottomCardContent}
        >
          <BlurView style={StyleSheet.absoluteFillObject} tint="light" intensity={50} />
          
          {/* å‡ºè¡Œæ–¹å¼ */}
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>å‡ºè¡Œæ–¹å¼</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false}>
              <View style={styles.routeTypeRow}>
                {(['driving', 'walking', 'bicycling', 'transit'] as const).map((type) => {
                  const icons = { driving: 'ğŸš—', walking: 'ğŸš¶', bicycling: 'ğŸš´', transit: 'ğŸšŒ' };
                  const labels = { driving: 'é©¾è½¦', walking: 'æ­¥è¡Œ', bicycling: 'éª‘è¡Œ', transit: 'å…¬äº¤' };
                  return (
                    <TouchableOpacity
                      key={type}
                      style={[
                        styles.routeTypeButton,
                        routePlanning.routeType === type && styles.activeRouteType
                      ]}
                      onPress={() => handleChangeRouteType(type)}
                    >
                      <Text style={[
                        styles.routeTypeText,
                        routePlanning.routeType === type && styles.activeRouteTypeText
                      ]}>
                        {icons[type]} {labels[type]}
                      </Text>
                    </TouchableOpacity>
                  );
                })}
              </View>
            </ScrollView>
          </View>

          {/* è·¯çº¿é€‰æ‹© */}
          {routePlanning.allRoutes.length > 0 && (
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>
                è·¯çº¿æ–¹æ¡ˆ ({routePlanning.allRoutes.length}æ¡)
              </Text>
              <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                <View style={styles.routeCardsRow}>
                  {routePlanning.allRoutes.map((route, index) => (
                    <RouteCard
                      key={route.id}
                      route={route}
                      isSelected={selectedRouteIndex === index}
                      onPress={() => handleSelectRoute(route, index)}
                    />
                  ))}
                </View>
              </ScrollView>
            </View>
          )}

          {/* è·¯çº¿ä¿¡æ¯ */}
          {routeResult && <RouteInfoCard route={routeResult} />}

          {/* æ“ä½œæŒ‰é’® */}
          <View style={styles.actionButtons}>
            <TouchableOpacity style={styles.actionButton} onPress={getCurrentLocation}>
              <Text style={styles.actionButtonText}>ğŸ“ è·å–ä½ç½®</Text>
            </TouchableOpacity>
            
            <TouchableOpacity
              style={[
                styles.actionButton,
                styles.primaryActionButton,
                routePlanning.isCalculating && styles.disabledButton
              ]}
              onPress={calculateRoute}
              disabled={routePlanning.isCalculating}
            >
              <Text style={styles.actionButtonText}>
                {routePlanning.isCalculating ? 'è®¡ç®—ä¸­...' : 'ğŸ—ºï¸ è§„åˆ’è·¯å¾„'}
              </Text>
            </TouchableOpacity>
            {routeResult && routeResult.polyline && routeResult.polyline.length > 0 && (
              <TouchableOpacity
                style={[
                  styles.actionButton,
                  styles.simulateActionButton,
                  isAnimating && styles.disabledButton
                ]}
                onPress={() => {
                  if (!isAnimating) {
                    animatePolyline(routeResult.polyline);
                  }
                }}
                disabled={isAnimating}
              >
                <Text style={styles.actionButtonText}>
                  {isAnimating ? 'ğŸ¬ æ¨¡æ‹Ÿä¸­...' : 'ğŸ¬ æ¨¡æ‹Ÿå¯¼èˆª'}
                </Text>
              </TouchableOpacity>
            )}
          </View>
        </ScrollView>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  map: {
    flex: 1,
  },
  topInputCard: {
    position: 'absolute',
    left: 20,
    right: 20,
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    zIndex: 1000,
  },
  inputRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
    minHeight: 44,
  },
  inputIcon: {
    fontSize: 12,
  },
  input: {
    flex: 1,
    fontSize: 12,
    color: '#333',
    paddingVertical: 12,
    padding: 0,
  },
  inputDivider: {
    height: 1,
    backgroundColor: '#E0E0E0',
    marginVertical: 10,
  },
  clearButton: {
    padding: 4,
    marginLeft: 8,
  },
  clearIcon: {
    fontSize: 16,
    color: '#999',
  },
  suggestionsContainer: {
    position: 'absolute',
    top: 160,
    left: 20,
    right: 20,
    maxHeight: 300,
    backgroundColor: 'white',
    borderRadius: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    zIndex: 999,
  },
  suggestionItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#F0F0F0',
  },
  suggestionIcon: {
    width: 32,
    height: 32,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
    borderRadius: 16,
    marginRight: 12,
  },
  suggestionContent: {
    flex: 1,
  },
  suggestionName: {
    fontSize: 15,
    fontWeight: '500',
    color: '#333',
    marginBottom: 4,
  },
  suggestionAddress: {
    fontSize: 12,
    color: '#999',
  },
  bottomCard: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: 'white',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    maxHeight: '65%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 5,
    overflow: 'hidden',
  },
  bottomCardContent: {
    padding: 20,
    paddingBottom: 30,
    backgroundColor: 'transparent',
  },
  section: {
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 12,
  },
  routeTypeRow: {
    flexDirection: 'row',
    gap: 10,
  },
  routeTypeButton: {
    backgroundColor: '#F5F5F5',
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  activeRouteType: {
    backgroundColor: '#2196F3',
    borderColor: '#2196F3',
  },
  routeTypeText: {
    fontSize: 12,
    fontWeight: '500',
    color: '#666',
  },
  activeRouteTypeText: {
    color: '#fff',
  },
  routeCardsRow: {
    flexDirection: 'row',
    gap: 12,
  },
  actionButtons: {
    flexDirection: 'row',
    gap: 10,
    flexWrap: 'wrap',
  },
  actionButton: {
    flex: 1,
    minWidth: 100,
    backgroundColor: '#2196F3',
    paddingVertical: 10,
    borderRadius: 10,
    alignItems: 'center',
    justifyContent: 'center',
  },
  primaryActionButton: {
    backgroundColor: '#4CAF50',
  },
  simulateActionButton: {
    backgroundColor: '#9C27B0',
  },
  disabledButton: {
    backgroundColor: '#CCC',
    opacity: 0.6,
  },
  actionButtonText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
  },
});
                  